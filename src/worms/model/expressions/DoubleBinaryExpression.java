package worms.model.expressions;import be.kuleuven.cs.som.annotate.*;/** * A class of binary arithmetic expressions. *   A binary expression involves a single operator applied *   to a left-hand operand and a right-hand operand. *  * @version  2.0 * @author   Eric Steegmans */public abstract class DoubleBinaryExpression extends DoubleComposedExpression {	/**	 * Initialize this new binary expression with given operands.	 *	 * @param  left	 *         The left operand for this new binary expression.	 * @param  right	 *         The right operand for this new binary expression.	 * @post   The left operand of this new binary expression is the	 *         same as the given left operand.	 *       | new.getLeftOperand() == left	 * @post   The right operand of this new binary expression is the	 *         same as the given right operand.	 *       | new.getRightOperand() == right	 * @throws IllegalOperandException	 *         This new binary expression cannot have the given left	 *         operand or the given right operand as its operand.	 *      |     (! canHaveAsOperand(left))	 *      |  || (! canHaveAsOperand(right))	 */	@Model	protected DoubleBinaryExpression(DoubleExpressions left, DoubleExpressions right)			throws IllegalOperandException {		if (!canHaveAsOperand(left))			throw new IllegalOperandException(this, left);		if (!canHaveAsOperand(right))			throw new IllegalOperandException(this, right);		setOperandAt(1, left);		setOperandAt(2, right);	}	/**	 * Return the number of operands involved in this binary expression.	 *	 * @return A binary expression always involves two operands.	 *       | result == 2	 */	@Override	@Basic	public final int getNbOperands() {		return 2;	}	/**	 * Check whether this binary expression can have the given	 * number as its number of operands.	 *	 * @return True if and only if the given number is 2.	 *       | result == (number == 2)	 */	@Override	@Raw	public final boolean canHaveAsNbOperands(int number) {		return number == 2;	}	/**	 * Return the operand of this binary expression at the given index.	 * 	 * @return If the given index is 1, the left operand of this	 *         binary expression; otherwise the right operand of	 *         this binary expression.	 *       | if (index == 1)	 *       |   then result == getLeftOperand()	 *       |   else result == getRightOperand()	 */	@Override	@Raw	public final Expression getOperandAt(int index)			throws IndexOutOfBoundsException {		if ((index != 1) && (index != 2))			throw new IndexOutOfBoundsException();		if (index == 1)			return getLeftOperand();		else			return getRightOperand();	}	/**	 * Set the operand for this binary expression at the given	 * index to the given operand.	 */	@Override	@Raw	protected void setOperandAt(int index, DoubleExpressions operand) {		if (index == 1)			this.leftOperand = operand;		else			this.rightOperand = operand;	}	/**	 * Return the left operand of this binary expression.	 */	@Basic	public DoubleExpressions getLeftOperand() {		return leftOperand;	}	/**	 * Variable referencing the left operand of this	 * binary expression.	 *	 * @note   This variable is not qualified final, such that operands	 *         can be changed in cloning unary expressions.	 */	private DoubleExpressions leftOperand;	/**	 * Return the right operand of this binary expression.	 */	@Basic	public DoubleExpressions getRightOperand() {		return rightOperand;	}	/**	 * Variable referencing the right operand of this	 * binary expression.	 *	 * @note   This variable is not qualified final, such that operands	 *         can be changed in cloning unary expressions.	 */	private DoubleExpressions rightOperand;	/**	 * Return a textual representation of this binary expression.	 *	 * @return If both operands of this binary expression are basic expressions,	 *         the textual representation of the left operand of this binary	 *         expression, followed by the symbol representing the operator	 *         of this binary expression followed by the textual representation	 *         of the right operand of this binary expression.	 *       | if ( (getLeftOperand() instanceof BasicExpression) &&	 *       |      (getRightOperand() instanceof BasicExpression) )	 *       |   then result.equals	 *       |          (getLeftOperand().toString() + getOperator() +	 *       |           getRightOperand().toString())	 * @return If the left operand of this binary expression is a basic expression	 *         and the right operand of this binary expression is a composed expression,	 *         the textual representation of the left operand of this binary	 *         expression, followed by the symbol representing the operator	 *         of this binary expression followed by the textual representation	 *         of the right operand of this binary expression in parenthesis.	 *       | if ( (getLeftOperand() instanceof BasicExpression) &&	 *       |      (getRightOperand() instanceof ComposedExpression) )	 *       |   then result.equals	 *       |          (getLeftOperand().toString() + getOperator() +	 *       |           "(" + getRightOperand().toString() + ")")	 * @return If the left operand of this binary expression is a composed expression	 *         and the right operand of this binary expression is a basic expression,	 *         the textual representation of the left operand of this binary	 *         expression in parenthesis, followed by the symbol representing the operator	 *         of this binary expression followed by the textual representation	 *         of the right operand of this binary expression.	 *       | if ( (getLeftOperand() instanceof ComposedExpression) &&	 *       |      (getRightOperand() instanceof BasicExpression) )	 *       |   then result.equals	 *       |          ("(" + getLeftOperand().toString() + ")" + getOperator() +	 *       |           getRightOperand().toString())	 * @return If both operands of this binary expression are composed expressions,	 *         the textual representation of the left operand of this binary	 *         expression in parenthesis, followed by the symbol representing the operator	 *         of this binary expression followed by the textual representation	 *         of the right operand of this binary expression in parenthesis.	 *       | if ( (getLeftOperand() instanceof ComposedExpression) &&	 *       |      (getRightOperand() instanceof ComposedExpression) )	 *       |   then result.equals	 *       |          ("(" + getLeftOperand().toString() + ")" + getOperator() +	 *       |           "(" + getRightOperand().toString() + ")")	 * @note   In the specification of this method, we assume that the classification of	 *         expressions into basic expressions and composed expressions is total. This	 *         means that we assume that no other kinds of expressions will ever be	 *         introduced next to basic expressions and composed expressions.	 */	@Override	public String toString() {		String result;		if (getLeftOperand() instanceof DoubleBasicExpression)			result = getLeftOperand().toString();		else if (getLeftOperand() instanceof DoubleComposedExpression)			result = "(" + getLeftOperand().toString() + ")";		else			throw new Error("Unknown expression type!");		result += getOperatorSymbol();		if (getRightOperand() instanceof DoubleBasicExpression)			result += getRightOperand().toString();		else if (getRightOperand() instanceof DoubleComposedExpression)			result += "(" + getRightOperand().toString() + ")";		else			throw new Error("Unknown expression type!");		return result;	}}